from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.orm import Session
from typing import List, Optional, Any
import uuid

from app.database import get_db
from app.models.run import WorkflowRun
from app.models.workflow import Workflow
from app.auth import deps, models
from typing import Annotated
# from app.tasks.huey_tasks import execute_workflow_task
from pydantic import BaseModel
from datetime import datetime

router = APIRouter()

class RunCreate(BaseModel):
    workflow_id: str
    input_data: dict

class RunResponse(BaseModel):
    id: str
    workflow_id: str
    status: str
    input_data: dict
    output_data: Optional[dict] = None
    result: Optional[str] = None
    started_at: datetime
    completed_at: Optional[datetime] = None
    duration_seconds: float = 0.0
    error_message: Optional[str] = None

    class Config:
        from_attributes = True

    @staticmethod
    def calculate_duration(run: WorkflowRun) -> float:
        if run.completed_at:
            return (run.completed_at - run.started_at).total_seconds()
        if run.started_at:
            return (datetime.utcnow() - run.started_at).total_seconds()
        return 0.0

@router.post("", response_model=RunResponse)
async def create_run(
    run: RunCreate, 
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(deps.get_current_active_user)] = None
):
    # Verify workflow exists
    workflow = db.query(Workflow).filter(Workflow.id == run.workflow_id).first()
    if not workflow:
        raise HTTPException(status_code=404, detail="Workflow not found")

    db_run = WorkflowRun(
        id=str(uuid.uuid4()),  # Explicitly set UUID
        workflow_id=run.workflow_id,
        status="pending",
        input_data=run.input_data,
        started_at=datetime.utcnow(),  # Explicitly set started_at
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow()
    )
    # id is generated by UUIDMixin
    db.add(db_run)
    db.commit()
    db.refresh(db_run)
    
    # Trigger background task
    # Note: With HUEY_IMMEDIATE=True, this runs synchronously
    # Trigger background task via Huey
    # Trigger background task via RabbitMQ
    from app.queue.producer import publish_message
    
    # Payload matching what process_task expects
    message = {
        "task_id": db_run.id,
        "payload": {
            "workflow_config": {
                "graph_definition": workflow.graph_definition,
                "agents_config": workflow.agents_config
            },
            "input_data": run.input_data
        }
    }
    
    await publish_message(message)
    # Task ID is the run_id itself in our new system

    
    # Refresh to get any updates if synchronous
    db.refresh(db_run)
    
    return db_run

@router.get("", response_model=List[RunResponse])
async def list_runs(
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(deps.get_current_active_user)] = None
):
    runs = db.query(WorkflowRun).all()
    # Add computed fields if they are not properties on the model
    for run in runs:
        if run.completed_at:
            run.duration_seconds = (run.completed_at - run.started_at).total_seconds()
        elif run.started_at:
            run.duration_seconds = (datetime.utcnow() - run.started_at).total_seconds()
        else:
            run.duration_seconds = 0.0
        
        # Populate result from final_output if available
        if run.output_data and "final_output" in run.output_data:
            run.result = run.output_data["final_output"]
            
    return runs

@router.get("/{run_id}", response_model=RunResponse)
async def get_run(
    run_id: str, 
    db: Session = Depends(get_db),
    current_user: Annotated[models.User, Depends(deps.get_current_active_user)] = None
):
    run = db.query(WorkflowRun).filter(WorkflowRun.id == run_id).first()
    if not run:
        raise HTTPException(status_code=404, detail="Run not found")
    
    # Compute duration
    if run.completed_at:
        run.duration_seconds = (run.completed_at - run.started_at).total_seconds()
    elif run.started_at:
        run.duration_seconds = (datetime.utcnow() - run.started_at).total_seconds()
    else:
        run.duration_seconds = 0.0

    # Populate result from final_output if available
    if run.output_data and "final_output" in run.output_data:
        run.result = run.output_data["final_output"]
        
    return run
